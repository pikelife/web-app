// Generated by CoffeeScript 1.8.0
(function() {
  var $, Error, GraphDatabase, Node, Relationship, Request, Transaction, URL, assert, lib, _transform;

  $ = require('underscore');

  assert = require('assert');

  Error = require('./errors').Error;

  lib = require('../package.json');

  Node = require('./Node');

  Relationship = require('./Relationship');

  Request = require('request');

  Transaction = require('./Transaction');

  URL = require('url');

  module.exports = GraphDatabase = (function() {
    GraphDatabase.prototype.headers = {
      'User-Agent': "node-neo4j/" + lib.version,
      'X-Stream': 'true'
    };

    function GraphDatabase(opts) {
      if (opts == null) {
        opts = {};
      }
      if (typeof opts === 'string') {
        opts = {
          url: opts
        };
      }
      this.url = opts.url, this.headers = opts.headers, this.proxy = opts.proxy, this.agent = opts.agent;
      if (!this.url) {
        throw new TypeError('URL to Neo4j required');
      }
      this.headers || (this.headers = {});
      $(this.headers).defaults(this.constructor.prototype.headers);
    }

    GraphDatabase.prototype.http = function(opts, cb) {
      var body, headers, method, path, raw, req;
      if (opts == null) {
        opts = {};
      }
      if (typeof opts === 'string') {
        opts = {
          path: opts
        };
      }
      method = opts.method, path = opts.path, headers = opts.headers, body = opts.body, raw = opts.raw;
      if (!path) {
        throw new TypeError('Path required');
      }
      method || (method = 'GET');
      headers || (headers = {});
      req = Request({
        method: method,
        url: URL.resolve(this.url, path),
        proxy: this.proxy,
        headers: $(headers).defaults(this.headers),
        agent: this.agent,
        json: body != null ? body : true,
        gzip: true
      }, cb && (function(_this) {
        return function(err, resp) {
          if (err) {
            return cb(err);
          }
          if (raw) {
            return cb(null, resp);
          }
          if (err = Error._fromResponse(resp)) {
            return cb(err);
          }
          return cb(null, _transform(resp.body));
        };
      })(this));
      req.start();
      return req.req;
    };

    GraphDatabase.prototype.cypher = function(opts, cb, _tx) {
      var body, commit, format, formats, headers, lean, method, params, path, queries, query, rollback, single;
      if (opts == null) {
        opts = {};
      }
      if (typeof opts === 'string') {
        opts = {
          query: opts
        };
      }
      if (opts instanceof Array) {
        opts = {
          queries: opts
        };
      }
      queries = opts.queries, query = opts.query, params = opts.params, headers = opts.headers, lean = opts.lean, commit = opts.commit, rollback = opts.rollback;
      if (!_tx && rollback) {
        throw new Error('Illegal state: rolling back without a transaction!');
      }
      if (commit && rollback) {
        throw new Error('Illegal state: both committing and rolling back!');
      }
      if (rollback && (query || queries)) {
        throw new Error('Illegal state: rolling back with query/queries!');
      }
      if (!_tx && commit === false) {
        throw new TypeError('Can’t refuse to commit without a transaction! To begin a new transaction without committing, call `db.beginTransaction()`, and then call `cypher` on that.');
      }
      if (!_tx && !(query || queries)) {
        throw new TypeError('Query or queries required');
      }
      if (query && queries) {
        throw new TypeError('Can’t supply both a single query and a batch of queries! Do you have a bug in your code?');
      }
      if (queries && params) {
        throw new TypeError('When batching multiple queries, params must be supplied with each query, not globally.');
      }
      if (queries && lean) {
        throw new TypeError('When batching multiple queries, `lean` must be specified with each query, not globally.');
      }
      if (!(_tx != null ? _tx._id : void 0) && !(query || queries) && (commit || rollback)) {
        cb(null, null);
        return;
      }
      method = 'POST';
      if (rollback) {
        method = 'DELETE';
      }
      path = '/db/data/transaction';
      if (_tx != null ? _tx._id : void 0) {
        path += "/" + _tx._id;
      }
      if (commit || !_tx) {
        path += "/commit";
      }
      if (query) {
        queries = [
          {
            query: query,
            params: params,
            lean: lean
          }
        ];
        single = true;
      } else {
        single = !queries;
        queries || (queries = []);
      }
      formats = [];
      body = {
        statements: (function() {
          var _i, _len, _ref, _results;
          _results = [];
          for (_i = 0, _len = queries.length; _i < _len; _i++) {
            query = queries[_i];
            if (typeof query === 'string') {
              query = {
                query: query
              };
            }
            if (query.headers) {
              throw new TypeError('When batching multiple queries, custom request headers cannot be supplied per query; they must be supplied globally.');
            }
            _ref = query, query = _ref.query, params = _ref.params, lean = _ref.lean;
            formats.push(format = lean ? 'row' : 'rest');
            _results.push({
              statement: query,
              parameters: params || {},
              resultDataContents: [format]
            });
          }
          return _results;
        })()
      };
      return this.http({
        method: method,
        path: path,
        headers: headers,
        body: body,
        raw: true
      }, (function(_this) {
        return function(err, resp) {
          var columns, data, error, errors, i, result, results, _ref;
          if (err) {
            return cb(err);
          }
          if (err = Error._fromResponse(resp)) {
            return cb(err);
          }
          if (_tx != null) {
            _tx._updateFromResponse(resp);
          }
          _ref = resp.body, results = _ref.results, errors = _ref.errors;
          results = (function() {
            var _i, _len, _results;
            _results = [];
            for (i = _i = 0, _len = results.length; _i < _len; i = ++_i) {
              result = results[i];
              columns = result.columns, data = result.data;
              format = formats[i];
              _results.push($(data).pluck(format).map(function(row) {
                var column, j, _j, _len1;
                result = {};
                for (j = _j = 0, _len1 = columns.length; _j < _len1; j = ++_j) {
                  column = columns[j];
                  result[column] = row[j];
                }
                if (format === 'rest') {
                  result = _transform(result);
                }
                return result;
              }));
            }
            return _results;
          })();
          if (single) {
            if (queries.length) {
              assert.equal(queries.length, 1, 'There should be *exactly* one query given.');
              assert(results.length <= 1, 'There should be *at most* one set of results.');
              results = results[0];
            } else {
              assert.equal(results.length, 0, 'There should be *no* results.');
              results = null;
            }
          }
          if (errors.length) {
            error = errors[0];
            err = Error._fromTransaction(error);
          }
          return cb(err, results);
        };
      })(this));
    };

    GraphDatabase.prototype.beginTransaction = function() {
      return new Transaction(this);
    };

    GraphDatabase.prototype.getLabels = function(cb) {
      return this.http({
        method: 'GET',
        path: '/db/data/labels'
      }, cb);
    };

    GraphDatabase.prototype.getPropertyKeys = function(cb) {
      return this.http({
        method: 'GET',
        path: '/db/data/propertykeys'
      }, cb);
    };

    GraphDatabase.prototype.getRelationshipTypes = function(cb) {
      return this.http({
        method: 'GET',
        path: '/db/data/relationship/types'
      }, cb);
    };

    return GraphDatabase;

  })();

  _transform = function(obj) {
    var key, map, node, rel, val;
    if ((!obj) || (typeof obj !== 'object')) {
      return obj;
    }
    if (obj instanceof Array) {
      return obj.map(_transform);
    }
    if (rel = Relationship._fromRaw(obj)) {
      return rel;
    }
    if (node = Node._fromRaw(obj)) {
      return node;
    }
    map = {};
    for (key in obj) {
      val = obj[key];
      map[key] = _transform(val);
    }
    return map;
  };

}).call(this);

//# sourceMappingURL=GraphDatabase.js.map
